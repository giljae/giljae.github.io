---
title:  "Netflix내의 마이크로서비스가 데이터를 처리하는 방법 (Gutenberg)"
tags: Netflix, Microservice
---
마이크로서비스 아키텍처에서는 단일 서비스에서 여러 목적지로 데이터 세트를 전파하는 것이 어려울 수 있다.

여기서 말하는 데이터 세트는 서비스 구성, 배치 작업 결과등의 모든 것을 의미 할 수 있다.

이러한 것들은 시간이 지남에 따라 종종 업데이트되어야 하기도 한다.

예를 들어서 Netflix에서는 수많은 A/B 테스트를 실행하고 있고 이런 테스트는 여러 서비스를 걸쳐서 수행되기에 테스트 담당자는 구성을 즉시 조정할 수 있어야 한다. 그리고 문제 발생시 이전 버전으로 롤백을 해야 한다.

다른 예는 머신 러닝 모델의 결과에 대한 배포이다. 머신 러닝 모델의 결과는 여러 팀에서 사용되지만, 모델을 담당하는 팀이 고가용성 서비스에 대한 관심이 높진 않다. 그리고 데이터 결과에 대한 활동들은 여러 팀이 활동하기에 중앙 집중화하는 것에 대해 가치가 있다고 판단된다.

하지만, 인프라 수준의 지원이 없다면 모든 팀은 성공을 위해 자체 솔루션을 구축하게 된다. 데이터 세트의 크기는 작게는 몇 바이트에서 많게는 몇 기가 바이트까지 다양한데 각 팀에서 이런 솔루션을 구축하는 것보다는 작업자가 빠르게 변경할 수 있도록 Tool을 제공하는 것이 중요하다.

Netflix에서는 Gutenberg라는 데이터 세트 Pub/Sub 시스템을 사용한다.

Gutenberg를 사용하면 특정 버전의 데이터 세트를 전파 할 수 있다. 데이터 세트의 각 버전은 변경이 불가능하며 데이터의 전체 뷰를 나타낸다. 이전 버전의 데이터에는 의존하지 않는다.

Gutenberg를 사용하면 Debugging 및 데이터를 이용한 머신 러닝 모델의 재학습과 같은 사용 사례에 이용될 수 있다.

# 데이터 모델

![image](https://user-images.githubusercontent.com/111643/116038831-ec0c2b80-a6a4-11eb-90be-499a680e7dd8.png)

Gutenberg의 최상위 구조는 “Topic”이다. Publisher는 Topic에 게시하고 Consumer는 Topic을 기반으로 소비한다. Publisher가 게시하면 새롭게 증가된 “Version”이 생성된다. 각 Version에 대해서는 유지 개수 혹은 유지 기간을 설정할 수 있다.

각 Version에는 Meta data(Key/Value)와 데이터 포인터가 포함되어 있고, 데이터 포인터는 게시한 실제 데이터가 저장된 위치를 가리키는 특수 메타 데이터이다. 현재 Gutenberg는 직접 데이터 포인터와 S3 데이터 포인터를 지원하고 있고 직접 데이터 포인터는 일반적으로 데이터가 작을 때(약 1MB미만)에 사용되며 S3는 데이터가 클 때 백업 저장소로 사용된다.

![image](https://user-images.githubusercontent.com/111643/116038946-12ca6200-a6a5-11eb-990d-05209423e8f8.png)

Gutenberg는 지역, 응용 프로그램, 클러스터등 특정 Consumer 집합에 게시 범위를 지정할 수 있는 기능을 제공한다. 단일 클러스터로 데이터 변경 사항을 카나리아 방식으로 변경하거나, 변경 사항을 점진적으로 Roll-out하거나, 데이터 세트를 제한하여 어플리케이션의 서브 세트만 구독할 수 있도록 지원한다. Publisher는 특정 데이터 버전의 게시 범위를 결정하고 이전에 게시된 버전에 범위를 추가할 수 있다. 다시 말해서 최신 버전의 개념이 범위에 따라 달라진다는 의미이다. 두 응용 프로그램은 Publisher가 만든 범위에 따라 서로 다른 버전의 데이터를 최신 버전으로 바라 볼 수 있다. Gutenberg는 최신 버전으로 전파할 대상을 결정하기 전에 Consumer 어플리케이션과 Publishing된 범위를 일치시킨다.

# 사용 사례
Gutenberg의 사용 사례는 단일 Publisher에서 여러 Consumer에게 다양한 크기의 데이터를 전파하는 것이다. 데이터는 Consumer에 의해 메모리상에 저장되어 클라이언트 코드에 의해 Access되고 원자적으로 교환되는 “전체 Cache”로 사용된다. 이런 사용 사례는 느슨하게 그룹핑하여 구성할 수 있다.

예를 들어서 Cache 구성, 지원되는 장치 유형 ID, 지원되는 지불 방법 및 A/B 테스트 구성등

Gutenburg는 데이터의 Pub/Sub을 추상화하여 Publisher가 Consumer에게 영향을 주지 않고 응용 어플리케이션을 자유롭게 반족 할 수 있게 도와준다. 경우에 따라 Gutenberg의 관리 UI를 통해 Publishing이 수행되므로 팀에서 Publisher 기능을 전혀 관리하지 않아도 된다.

Gutenberg의 또 다른 사용 사례는 Version이 지정된 데이터 저장소이다. 이것은 과거 데이터를 기반으로 모델을 구축하고 훈련하는 과정을 반복하는 머신 러닝 프로그램에 일반적인 케이스이다. Gutenberg를 사용하여 계산 결과를 별개의 버전의 데이터 세트로 저장하고 전파하고 온라인 Use-case에서는 최신 Version의 데이터 세트를 사용하여 실시간 요청을 처리하고 “오프라인” Use-case에서는 동일한 Topic의 히스토리 데이터를 사용할 수 있다.

이런 점을 보면, 다들 이렇게 생각할 수 있다. 그냥 Kafka나 Pub/Sub 구조의 이벤트 솔루션을 사용하면 되지 않나? 중요한 점은 Gutenberg가 이벤트 시스템으로 설계되지 않았고 데이터 버전 관리 및 전파를 위해서 존재한다는 점이다. 업데이트를 요청하면 현재 많은 버전이 있다고 해도 최신 버전으로만 제공된다. 전통적인 Pub/Sub 구조의 이벤트 시스템은 크기가 작고 순서대로 소비되는 메시지에 적합하다. 그러나 Gutenberg는 데이터 세트에 대한 불변의 전체뷰를 게시하고 사용하도록 설계되었다.

# 아키텍처
Gutenberg는 gRPC 및 REST API가 포함된 서비스와 gRPC API를 사용하는 Java Client Library로 구성되어 있다.

![image](https://user-images.githubusercontent.com/111643/116039037-2e356d00-a6a5-11eb-8d74-b28f06196c05.png)

# Client
Gutenberg 클라이언트 라이브러리는 구독 관리, S3 업로드/다운로드, Atlas metric 및 Archaius properties 를 사용하여 작업을 처리한다. 서비스 검색에 Eureka를 사용하여 gRPC를 통해 Gutenberg 서비스와 통신한다.

# Publishing
Publisher는 API를 사용하여 문자열, 파일 또는 바이트 배열을 게시한다. 데이터 크기에 따라 데이터가 직접 데이터 포인터로 게시되거나 S3에 업로드 된 후 S3 데이터 포인터로 게시 될 수 있다. 클라이언트는 요청자를 대신하여 Payload를 S3에 업로드하거나 S3에 이미 존재하는 Payload에 대한 메타 데이터만 게시 할 수 있다.

직접 데이터 포인터는 자동으로 복제된다. S3에 게시된 데이터는 기본적으로 게시자가 여러 지역에 업로드 하지만 요청자가 구성 할 수 도 있다.

# 구독 관리
클라이언트 라이브러리는 Consumer를 위한 구독 관리 기능을 제공한다. 이 기능을 통해 사용자는 특정 Topic에 대한 구독을 작성할 수 있고, 라이브러리는 이를 기반으로 데이터를 검색한다. 구독은 Polling Model로 작동되며 30초마다 서비스에 새 업데이트를 요청하여 마지막으로 전달 받은 버전을 제공한다. 문제 발생시 재시도하는 로직은 기본으로 탑재되어 있다.

# Consumption APIs
Gutenberg는 저수준 gRPC API를 Wrapping하여 추가적인 기능을 제공하는 고수준 Client API를 제공한다. 예를 들어서 특정 Topic과 Version에 대한 데이터를 다운로드한다고 할때, Netflix Hollow에 연결된 구성 요소를 광범위하게 사용할 수 있다. 또는 특정 시간에 Topic의 최신 버전을 얻는 방법도 존재한다.

# Client 탄력성 및 관찰성
Gutenberg는 Comsuming 서비스를 성공적으로 하도록 설계 되었다. 이를 염두해두고 Client Library는 Gutenberg 서비스와 통신 할 수 없는 경우에 대해 대비하여 구현되었다. HTTP 요청 재시도 횟수가 소진 된 후에 Client는 S3에서 Topic에 대한 fallback cache를 다운로드 하고 이를 기반으로 작동한다. 해당 Cache에는 업데이트를 적용해야 하는지 여부와 Meta 데이터 자체 또는 S3에서 데이터를 가져와야 하는 위치를 결정하는데 필요한 모든 정보가 포함되어 있다. 이를 통해 Client는 서비스를 사용하지 않고 데이터를 Fetch할 수 있다.

Client Library 제공의 이점중 하나는 인프라 전체의 문제 또는 특정 응용 프로그램의 문제를 경고하는데 사용할 수 있는 Metric 제공하는 기능이다. 이런 측정 항목은 Gutenberg에서 게시 및 전파를 모니터링하고 광범위한 문제가 발생했을 경우 이를 경고하는데 사용된다. 또한 일부 클라이언트는 이런 측정 항목을 사용하여 개별 게시 실패 또는 특정 Topic 사용 실패와 같은 오류에 대해서도 알려준다.

# Server
Gutenberg 서비스는 gRPC 및 REST End-point를 공개하는 Governator/Tomcat 어플리케이션이다. 지속성을 위해서 글로벌하게 복제된 Cassandra Cluster를 사용아여 모든 지역에 게시 메타 데이터를 전파한다. Consumer 요청을 처리하는 인스턴스는 게시 요청을 처리하는 인스턴스와 별도로 확정된다. 일반적으로 게시 요청보다 Consuming 요청이 약 1000배 더 많기에 Publishing을 Consuming으로 부터 격리시킨다. 그 이유는 갑자기 Publishing이 급증해도 Consuming에 영향을 미치지 않기 위함이고 반대도 마찬가지이다.

Consumer 요청 클러스터의 각 인스턴스는 자체 메모리의 최신 게시에 대한 Cache를 유지 관리하여 몇 초마다 Cassandra에서 새롭게 갱신된다. 이는 트래픽을 Cassandra 클러스터로 전달하지 않고 클라이언트에서 오는 대량의 Polling 요청을 처리하기 위함이다.

여러 지역의 S3 Bucket에 데이터가 게시 된 경우에는 서버는 클라이언트의 위치에 따라 다운로드 할 클라이언트로 다시 보낼 Bucket을 결정한다. 이 경우 가장 가까운 Region에서 Bucket을 클라이언트에 제공하고 Region이 중단 된 경우 클라이언트가 다른 Region으로 fallback되도록 한다.

구독 데이터를 Consumer에게 반환하기 전에 Gutenburg는 데이터에 대한 일관성 검사를 선행한다. 검사가 실패하고 Polling 클라이언트가 일부 데이터를 사용한 경우 서비스는 아무것도 리턴하지 않으므로 사실상 사용 가능한 업데이트가 없음을 의미한다. Polling 클라이언트가 데이터를 사용하지 않은 경우에는 히스토리를 조회하고 일관성 검사를 통해 최신 데이터를 리턴한다. 클라이언트가 새로운 데이터를 Polling할 때 가장 최근에 게시된 버전과 관련된 메타 데이터가 복제된 Cassandra 계층에서 복제 지연이 발생하기 때문이다. 그리고 데이터를 가져올때 실패할 경우를 대비해 서버에서는 일관성 검사를 실행한다.

# Data Resilient
## Pinning
어플리케이션의 개발 환경에서는 배포가 잘못되거나 배포를 Rollback하는 정책이 필요하다. 데이터 중심의 아키텍처는 시간이 지남에 따라서 변경되는 데이터에 의해 작동되기에 이 부분은 매우 까다롭다.

Guternberg에서는 문제가 발생하면 마지막 안정버전의 데이터로 Rollback할 수 있는 방법이 필요하다. 이를 제공하기 위해서 Gutenberg는 Topic을 특정 버전에 고정하는 기능을 제공한다.

Pin은 최신 버전의 데이터를 무시하고 클라이언트가 해당 버전으로 Update하도록 도와준다.

따라서 관리자가 마지막의 안정버전을 모르더라도 빠르게 처리할 수 있다.

## Incremental Rollout
새로운 코드를 배포할때는 카나리아 혹은 점진적으로 Rollout하는 방식으로 수행한다.

Gutenberg가 제공하는 기능중에 SPinnaker 파이프라인을 통해 데이터 게시를 Rollout라는 것을 제공한다. 특정 Topic의 경우 사용자는 자신이 게시 할 범위에 지연 시간을 구성하게 된다. 그리고 해당 Topic에 게시하게 되면 파이프 라인이 시작되어 동일한 데이터 버전이 각 범위에 점차적으로 게시되게 된다. 사용자는 파이프라인과 상호 작용할 수 있다.

## Scale
Gutenberg는 지난 3년간 Netflix에서 사용되고 있고, 수만 가지의 Topic을 Production에 저장하고 있다. 이 중에 약 1/4이 지난 6개월 동안 한번 이상은 Publishing되었다. Topic은 1분에 수십번에서 몇달간 한번까지 다양하게 게시되었으며, 평균적으로 약 12시간 간격으로 초당 약 1~2번의 게시가 가능하다.

24시간 동안 적어도 한개의 Topic에 가입된 노드의 수는 6자리 미만이고, 이 노드중 하나가 구독하는 최대 Topic수는 200개이다.

# 향후 작업 계획
Polyglot 지원 (현재는 Java만 지원하지만, Node.js 및 Python을 지원할 계획을 가지고 있다.)

암호화 지원 (민감한 데이터의 경우 암호화 및 암호 해독 기능을 제공하여 사용 될 수 있도록 준비중이다.)

Topic 정리 (Topic을 게시하거나 사용하지 않는 사람이 있어도 명시적으로 삭제하지 않는한 Topic이 계속 유지되기에 Elasticsearch에서 색인화 작업을 거쳐서 Topic을 정리하는 시스템을 구축할 계획)

References:
* https://medium.com/netflix-techblog/how-netflix-microservices-tackle-dataset-pub-sub-4a068adcc9a
