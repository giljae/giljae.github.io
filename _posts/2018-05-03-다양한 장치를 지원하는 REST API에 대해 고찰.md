---
layout: post
title:  "다양한 장치를 지원하는 REST API에 대해 고찰"
comments: true
tags: Netflix, REST
---

> “REST API는 일반적인 요청을 처리하는데 뛰어나며, 다수의 개발자가 API를 쉽게 사용할 수 있도록 하는 일련의 규칙을 수립합니다.”

위 모델에서는 모든 사람들이 규칙을 알고 있으면 엄청나게 강력해집니다. API 공급자는 일련의 규칙을 설정하고 API 소비자는 원하는 것을 얻으려면 공급자가 설정한 규칙을 준수해야 합니다.

그러나 점점 규모가 커지고 사람들이 디지털 콘텐츠 및 서비스를 사용하는 방식이 늘어나고 있는 상황에서는 위 단일 모델 원칙이 부족할 수 있습니다.

Netflix의 예를 들어 볼까요?

Netflix는 현재 게임 콘솔, 모바일, TV, 블루레이 플레이어, Tablet, PC 및 비디오를 스트리밍 할 수 있는 거의 모든 디바이스(약 800개 이상)에서 사용할 수 있습니다.

디바이스의 폭이 넓어지기 때문에 전체의 기능 변화를 관리하기가 어려워지는 잠재적인 문제가 발생합니다.

예를 들어 Google의 REST API는 일반적인 방식으로 디바이스의 요청을 처리 할 수 있지만, 그 중 어느것도 디바이스에 맞춰서 최적화하지 않았습니다. REST API가 데이터를 세부적으로 표현하는 리소스에 초점을 맞추기 때문입니다.

각 디바이스간의 차이점은 여러가지 경우가 존재합니다. 다음은 1:1 맞춤형 모델의 경우 지원하기 어려운 다기종 디바이스 기기간의 차이입니다.
* 서로 다른 디바이스는 서로 다른 메모리 용량을 가지고 있음
* 일부 디바이스는 고유하거나 독점적인 형식 혹은 전달 방법이 필요할 수 있음
* 일부 디바이스는 더 Depth가 깊은 형태의 계층적 문서 모델로 성능이 향상될 수 있음
* 디바이스마다 다른 화면 크기를 지니고 있기에 어떤 데이터가 필요한지에 영향을 줄 수 있음
* 서로 다른 디바이스는 서로 다른 사용자 상호 작용 모델을 허용하며 메타 데이터 필드, 전달 방법, 상호 작용 모델등에 영향을 줄 수 있음

iPhone과 TV의 차이점과 다른 사용자 경험을 제공하는 방법과 TV에 투영되는 XBox와 Wii는 하드웨어 제약 조건과 상호 작용하는 방식이 서로 다르고 제약 조건을 지원하기 위해 서로 다른 API가 필요할 수 있습니다. 800가지가 넘는 다양한 디바이스 유형을 고려할 경우 분산해서 제공하는 방안이 압도적입니다. 그리고 더 많은 제조사가 디바이스를 계속 혁신함에 따라 편차가 커질 여지가 존재합니다.

이러한 기기의 차이 때문에 Netflix UI팀은 각 기기별 사용자에게 더 나은 서비스를 제공하기 위해 REST API를 Redesign하기로 결정 합니다.

위에서 언급한 것처럼 기존의 OSFA(One-size-fits-all) REST API 접근 방식에 제한 사항이 존재합니다. Netflix의 스트리밍 서비스는 800개 이상의 서로 다른 기기에서 사용할 수 있으며, 거의 모든 기기가 비공개 API로 부터 콘텐츠를 수신합니다. Netflix의 경우 OSFA API를 사용하여 다양한 기기를 지원하는 것은 성공했지만 API팀, UI팀 또는 Netflix 스트리밍 고객에게 적합하지 않음을 깨달았습니다.

새롭게 디자인 된 API의 핵심은 800개 이상의 기기 유형에서 다양한 차이가 있다는 사실을 수용한 점입니다. Netflix가 2008년 부터 사용한 REST API를 포함한 대부분의 API는 일반적인 방식으로 기기의 요청을 처리하여 서버쪽 구현을 보다 효율적으로 만듭니다. 이 접근법에는 충분한 이유가 있는데, API 팀이 OSFA API를 제공하면 모든 사람이 따라야 하는 규칙을 설정하기 때문에 광범위한 API사용자와 확고한 관계를 유지할 수 있기 때문입니다.

이런 규칙은 효과적이긴 하지만 OSFA의 문제점은 API 소비자가 아닌 API 제공업체가 편리하게 사용할 수 있다는 점입니다. 따라서 OSFA는 이러한 기기의 차이점을 무시합니다.

Netflix의 새로운 모델은 OSFA 패러다임을 없애고, 각 기기의 차이점을 동등하게 지원하면서 포용하도록 설계되었습니다. 이를 위해서 API 개발 플랫폼을 통해 각 UI팀은 사용자 정의를 만들 수 있습니다. 이렇게 하므로써, Request/Response 모델은 각 팀의 UI에 맞게 최적화 될 수 있습니다.

많은 OSFA 구현에서 API는 아래의 형태로 제공됩니다.

![image](https://user-images.githubusercontent.com/111643/115838723-f0daa080-a454-11eb-9eaa-00a2e5ce4953.png)

위의 그림은 Netflix 환경을 시작하기 위해 PS3에 필요한 여러 요청을 대략적으로 보여줍니다. 다른 UI는 OSFA REST API에 대해 유사한 상호 작용 세트를 갖게 됩니다. 이는 API에서 모두 동일한 규칙을 준수해야 한다는 것을 의미합니다. REST API내부에는 콘텐츠 수집, 준비 및 전달을 수행하는 엔진이 존재합니다.

Google의 새 API는 OSFA API 모델에서 전체 API의 관리 기능을 손상시키지 않으면서 세분화 맞춤 설정이 가능하게 하는 모델로 이전 되었습니다. 다음 그림은 수정된 아키텍처를 보여줍니다.

![image](https://user-images.githubusercontent.com/111643/115838760-fa640880-a454-11eb-9d34-400182d42d76.png)

이 새로운 모델에서 UI는 사용자 요청에 대해 단일 지점을 만듭니다. 그 이후 사용자 요청에 대해 구문을 분석하고 Java API를 호출하는 처리기로 하부 API 제공 서비스를 호출합니다.

“클라이언트 코드”는 디바이스내에 있는 모든 코드를 의미합니다.

“서버 코드”는 서버에 존재하는 코드로 정의됩니다.

이 의미는 REST API의 경우에 경계를 나누는 기준이며, API 소비자와 API 제공자를 의미합니다.

![image](https://user-images.githubusercontent.com/111643/115838819-05b73400-a455-11eb-9c3a-063cfb7601bb.png)

Netflix의 경우 서버 코드에 많은 부분을 밀어 넣고 있습니다. 디바이스의 모든 코드는 클라이언트 코드로 간주되지만, 일부 클라이언트 코드는 서버에 위치합니다.

클라이언트 코드는 서버에 있는 전용 클라이언트 어댑터에 요청을 하게 됩니다.어댑터는 필요없는 필드 제거, 오류 처리 및 재시도, 응답 형식, 헤더 필드등의 정보를 처리합니다. 이 모든 처리는 특정 UI에 대한 사용자 정의입니다. 아래의 그림을 확인하세요.

![image](https://user-images.githubusercontent.com/111643/115838858-0f409c00-a455-11eb-99b8-31a3e32729ce.png)

위의 변화는 두 가지 측면이 있습니다.

첫째, 네트워크를 통해 진행되는 Request를 서버에서 처리하기 때문에 디바이스와 서버간의 효율적인 상호 작용이 가능합니다. 네트워크 비용은 트랜잭션 중 가장 비싸기 때문에 네트워크 요청 수를 줄이면 성능이 향상됩니다.

둘째, 최적화 된 어댑터를 구축해서 클라이언트 요청을 최종적으로 처리합니다.

이 접근 방식의 단점은 A/B 테스트 및 Multiple 테스트를 위해 더 많은 기기를 추가하고

더 많은 UI를 추가 할 경우 모든 개별 프로파일을 지원하는데 필요한 무수한 어댑터가 존재한다는 점입니다.

위에서 언급한 것처럼 일부 클라이언트 코드를 서버로 보내고 API를 제공하면 UI팀이 (API팀의 개입없이) 자체 어댑터 코드를 만들고 수정할 수 있으므로 개발 과정에서 훨씬 더 민첩할 수 있습니다. 이 들은 더 이상 규칙을 지시하거나 개발을 위한 병목이 되는 서버팀에 구속되지 않습니다. API 혁신은 UI팀에게 달려있게 됩니다.

UI팀이 HTML5, CSS3, JavaScript등의 기술에 더욱 숙련되어 있다는 점이 단점이긴 합니다.

이제는 서버측 기술을 배워야 합니다. 또 다른 문제는 UI팀이 서버 측 어댑터를 구현하기 때문에 리소스 집약적인 무한 루프 또는 기타 프로세스를 통해 API 서버를 중단시킬 가능성이 존재한다는 점입니다. 이를 보완하기 위해서 Netflix의 경우 Scrubbing Engine을 개발 하고 있습니다.

즉, OSFA 세계에서 장치의 코드는 서버를 쉽게 DDOS할 수 있으며, 서버에서 실행되는 경우 잠재적으로 더 큰 문제를 유발할 수 있습니다.
1. PS3와 같은 기기는 네트워크를 통해 홈화면을 Load하는 단일 요청을 합니다. (이 코드는 PS3 UI팀에서 작성하고 지원)
2. Groovy Adapter가 PS3 요청을 받고 구문 분석을 합니다. (PS3 UI 팀)
3. Adapater는 하나의 요청을 Java API로 매핑 (PS3 UI 팀)
4. 각 Java API는 요청에 필요한 콘텐츠를 제공하기 위해 종속 서비스를 호출
5. Java API에서 종속 서비스 사용이 불가능하거나 4xx, 5xx를 반환하면 Java API는 Adapter(API팀)에 폴백 및 오류 코드를 반환합니다.
6. Java API 트랜잭션이 성공적으로 완료되면 (API팀) 콘텐츠를 Adapter로 반환 합니다.
7. Adapter가 콘텐츠를 조작하고, 원하는 요소를 가져오거나 잘라내고 오류를 처리 (PS3 UI 팀)
8. Adapter는 PS3 홈 화면에 필요한 모든것을 포함하여 응답 형식을 지정합니다. (PS3 UI 팀)
9. 클라이언트에게 Payload를 전달합니다. (PS3 UI 팀)
10. 클라이언트가 구문을 분석하고 UI를 표현합니다. (PS3 UI 팀)

이 새로운 모델은 아직 초기 단계에 있으며, REST API를 사용하는 기기와 새로운 모델을 사용하는 기기로 현재 혼재되어 있습니다.

Source: https://medium.com/netflix-techblog/embracing-the-differences-inside-the-netflix-api-redesign-15fd8b3dc49d
